<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Gauss / Gauss-Jordan / Inverse</title>
    <style>
      body {
        background: #0a2c60;
        color: #ffffff;
        padding: 20px;
      }
      h1 {
        font-size: 50px;
        text-align: center;
        margin-bottom: 25px;
      }
      .card {
        background: #4fa4de;
        padding: 15px;
        border: 5px solid #000000;
      }
      .controls {
        display: flex;
        gap: 8px;
        justify-content: center;
        align-items: center;
        margin-bottom: 15px;
      }
      input[type="number"] {
        width: 70px;
        padding: 4px;
        text-align: center;
      }
      button {
        padding: 6px 12px;
        cursor: pointer;
      }
      table {
        margin: 10px auto;
      }
      td {
        padding: 3px;
      }
      .split-box {
        border: 5px solid #737c80;
        padding: 20px;
        background: #000000;
        margin-bottom: 15px;
      }
      .split-title {
        font-weight: bold;
        margin-bottom: 6px;
        text-align: center;
      }
      .step {
        margin-bottom: 6px;
      }
      .step-title {
        font-weight: bold;
        margin-bottom: 2px;
      }
      pre {
        background: #454343;
        padding: 6px;
        white-space: pre;
      }
      .solution-block {
        margin-top: 8px;
        padding-top: 6px;
        border-top: 1px solid #444;
      }
    </style>
  </head>

  <body>
    <h1>Matrix Solver</h1>

    <div class="card">
      <div class="controls">
        <label>Equations:</label>
        <input type="number" id="eqCount" value="2" min="1" max="10" />
        <label>Variables:</label>
        <input type="number" id="varCount" value="2" min="1" max="10" />
        <button onclick="createMatrix()">Create Matrix</button>
        <button id="solveBtn" onclick="solve()" disabled>Solve</button>
        <button onclick="clearAll()">Clear</button>
      </div>

      <div id="matrixContainer"></div>

      <div class="split-box">
        <div class="split-title">Gauss Elimination</div>
        <div id="gaussOutput"></div>
      </div>

      <div class="split-box">
        <div class="split-title">Gauss–Jordan</div>
        <div id="jordanOutput"></div>
      </div>

      <div class="split-box">
        <div class="split-title">Inverse of A</div>
        <div id="inverseSteps"></div>
        <pre id="inverseOutput"></pre>
      </div>
    </div>

    <script>
      const matrixContainer = document.getElementById("matrixContainer");
      const solveBtn = document.getElementById("solveBtn");
      const gaussOutput = document.getElementById("gaussOutput");
      const jordanOutput = document.getElementById("jordanOutput");
      const inverseSteps = document.getElementById("inverseSteps");
      const inverseOutput = document.getElementById("inverseOutput");
      const EPS = 1e-12;

      function createMatrix() {
        matrixContainer.innerHTML = "";
        gaussOutput.innerHTML = "";
        jordanOutput.innerHTML = "";
        inverseSteps.innerHTML = "";
        inverseOutput.textContent = "";

        const eq = +document.getElementById("eqCount").value;
        const vars = +document.getElementById("varCount").value;

        const tbl = document.createElement("table");
        for (let i = 0; i < eq; i++) {
          const tr = document.createElement("tr");
          for (let j = 0; j < vars; j++) {
            const td = document.createElement("td");
            const inp = document.createElement("input");
            inp.type = "number";
            inp.step = "any";
            inp.className = "matrix-cell";
            inp.id = `a_${i}_${j}`;
            inp.placeholder = `a${i + 1}${j + 1}`;
            td.appendChild(inp);
            tr.appendChild(td);
          }
          const rhsCell = document.createElement("td");
          rhsCell.textContent = "| ";
          const rhs = document.createElement("input");
          rhs.type = "number";
          rhs.step = "any";
          rhs.className = "matrix-cell";
          rhs.id = `b_${i}`;
          rhs.placeholder = `b${i + 1}`;
          rhsCell.appendChild(rhs);
          tr.appendChild(rhsCell);
          tbl.appendChild(tr);
        }
        matrixContainer.appendChild(tbl);
        solveBtn.disabled = false;
      }

      function clearAll() {
        matrixContainer.innerHTML = "";
        gaussOutput.innerHTML = "";
        jordanOutput.innerHTML = "";
        inverseSteps.innerHTML = "";
        inverseOutput.textContent = "";
        solveBtn.disabled = true;
      }

      function readMatrix() {
        const eq = +document.getElementById("eqCount").value;
        const vars = +document.getElementById("varCount").value;
        const M = [];
        for (let i = 0; i < eq; i++) {
          const row = [];
          for (let j = 0; j < vars; j++) {
            const v = parseFloat(document.getElementById(`a_${i}_${j}`).value);
            if (isNaN(v)) return null;
            row.push(v);
          }
          const bv = parseFloat(document.getElementById(`b_${i}`).value);
          if (isNaN(bv)) return null;
          row.push(bv);
          M.push(row);
        }
        return M;
      }

      function clone(A) {
        return A.map((r) => r.slice());
      }

      function fmt(x) {
        if (Math.abs(x) < EPS) return 0;
        if (Math.abs(x - Math.round(x)) < 1e-9) return Math.round(x);
        return +x.toFixed(6);
      }

      function matrixToString(M) {
        if (!M) return "";
        let s = "";
        for (let i = 0; i < M.length; i++) {
          for (let j = 0; j < M[0].length; j++) {
            s += String(fmt(M[i][j])).padStart(8, " ") + " ";
          }
          s += "\n";
        }
        return s;
      }

      function addStep(container, title, mat) {
        const div = document.createElement("div");
        div.className = "step";
        const t = document.createElement("div");
        t.className = "step-title";
        t.textContent = title;
        const pre = document.createElement("pre");
        pre.textContent = matrixToString(mat);
        div.appendChild(t);
        div.appendChild(pre);
        container.appendChild(div);
      }

      // Gaussian elimination
      function gaussian(A) {
        let M = clone(A);
        let rows = M.length,
          cols = M[0].length,
          r = 0;
        let steps = [];
        for (let c = 0; c < cols - 1 && r < rows; c++) {
          let piv = r;
          for (let i = r; i < rows; i++)
            if (Math.abs(M[i][c]) > Math.abs(M[piv][c])) piv = i;
          if (Math.abs(M[piv][c]) < EPS) continue;
          if (piv !== r) {
            [M[piv], M[r]] = [M[r], M[piv]];
            steps.push({
              title: `Swap R${piv + 1} ↔ R${r + 1}`,
              mat: clone(M),
            });
          }
          let pv = M[r][c];
          for (let j = c; j < cols; j++) M[r][j] /= pv;
          steps.push({
            title: `R${r + 1}=R${r + 1}/${fmt(pv)}`,
            mat: clone(M),
          });
          for (let i = r + 1; i < rows; i++) {
            let f = M[i][c];
            if (Math.abs(f) < EPS) continue;
            for (let j = c; j < cols; j++) M[i][j] -= f * M[r][j];
            steps.push({
              title: `R${i + 1}=R${i + 1}-(${fmt(f)})R${r + 1}`,
              mat: clone(M),
            });
          }
          r++;
        }
        return { M, steps };
      }

      function backSubstitution(U) {
        let rows = U.length,
          cols = U[0].length,
          n = cols - 1;
        let x = new Array(n).fill(0);
        for (let i = n - 1; i >= 0; i--) {
          let sum = 0;
          for (let j = i + 1; j < n; j++) sum += U[i][j] * x[j];
          x[i] = (U[i][n] - sum) / U[i][i];
        }
        return x;
      }

      // Gauss-Jordan
      function gaussJordan(A) {
        let M = clone(A);
        let rows = M.length,
          cols = M[0].length,
          r = 0;
        let steps = [];
        for (let c = 0; c < cols - 1 && r < rows; c++) {
          let piv = r;
          for (let i = r; i < rows; i++)
            if (Math.abs(M[i][c]) > Math.abs(M[piv][c])) piv = i;
          if (Math.abs(M[piv][c]) < EPS) continue;
          if (piv !== r) {
            [M[piv], M[r]] = [M[r], M[piv]];
            steps.push({
              title: `Swap R${piv + 1} ↔ R${r + 1}`,
              mat: clone(M),
            });
          }
          let pv = M[r][c];
          for (let j = 0; j < cols; j++) M[r][j] /= pv;
          steps.push({
            title: `R${r + 1}=R${r + 1}/${fmt(pv)}`,
            mat: clone(M),
          });
          for (let i = 0; i < rows; i++) {
            if (i === r) continue;
            let f = M[i][c];
            if (Math.abs(f) < EPS) continue;
            for (let j = 0; j < cols; j++) M[i][j] -= f * M[r][j];
            steps.push({
              title: `R${i + 1}=R${i + 1}-(${fmt(f)})R${r + 1}`,
              mat: clone(M),
            });
          }
          r++;
        }
        return { M, steps };
      }

      function readSolutionFromRREF(M) {
        let rows = M.length,
          cols = M[0].length,
          n = cols - 1;
        let x = new Array(n).fill(0);
        for (let i = 0; i < n && i < rows; i++) x[i] = M[i][n];
        return x;
      }

      // Rank calculation
      function rank(mat) {
        let M = clone(mat);
        let rows = M.length,
          cols = M[0].length;
        let r = 0;
        for (let c = 0; c < cols && r < rows; c++) {
          let piv = r;
          for (let i = r; i < rows; i++)
            if (Math.abs(M[i][c]) > Math.abs(M[piv][c])) piv = i;
          if (Math.abs(M[piv][c]) < EPS) continue;
          [M[piv], M[r]] = [M[r], M[piv]];
          let pv = M[r][c];
          for (let j = c; j < cols; j++) M[r][j] /= pv;
          for (let i = 0; i < rows; i++) {
            if (i === r) continue;
            let f = M[i][c];
            if (Math.abs(f) < EPS) continue;
            for (let j = c; j < cols; j++) M[i][j] -= f * M[r][j];
          }
          r++;
        }
        return r;
      }

      // Inverse with steps
      function inverseMatrixSteps(Acoef) {
        let n = Acoef.length;
        let M = new Array(n);
        for (let i = 0; i < n; i++) {
          M[i] = new Array(2 * n);
          for (let j = 0; j < n; j++) M[i][j] = Acoef[i][j];
          for (let j = 0; j < n; j++) M[i][j + n] = i === j ? 1 : 0;
        }
        let steps = [],
          r = 0;
        for (let c = 0; c < n && r < n; c++) {
          let piv = r;
          for (let i = r; i < n; i++)
            if (Math.abs(M[i][c]) > Math.abs(M[piv][c])) piv = i;
          if (Math.abs(M[piv][c]) < EPS) return { inv: null, steps };
          if (piv !== r) {
            [M[piv], M[r]] = [M[r], M[piv]];
            steps.push({
              title: `Swap R${piv + 1} ↔ R${r + 1}`,
              mat: clone(M),
            });
          }
          let pv = M[r][c];
          for (let j = 0; j < 2 * n; j++) M[r][j] /= pv;
          steps.push({
            title: `R${r + 1}=R${r + 1}/${fmt(pv)}`,
            mat: clone(M),
          });
          for (let i = 0; i < n; i++) {
            if (i === r) continue;
            let f = M[i][c];
            if (Math.abs(f) < EPS) continue;
            for (let j = 0; j < 2 * n; j++) M[i][j] -= f * M[r][j];
            steps.push({
              title: `R${i + 1}=R${i + 1}-(${fmt(f)})R${r + 1}`,
              mat: clone(M),
            });
          }
          r++;
        }
        let inv = new Array(n);
        for (let i = 0; i < n; i++) inv[i] = M[i].slice(n, 2 * n);
        return { inv, steps };
      }

      function solve() {
        gaussOutput.innerHTML = "";
        jordanOutput.innerHTML = "";
        inverseSteps.innerHTML = "";
        inverseOutput.textContent = "";

        let A = readMatrix();
        if (!A) {
          alert("املئي كل الخانات");
          return;
        }

        let eq = A.length;
        let vars = A[0].length - 1;

        let Acoef = A.map((r) => r.slice(0, vars));
        let rankA = rank(Acoef);
        let rankAug = rank(A);
        let status = "unique";

        if (rankA < rankAug) status = "no";
        else if (rankA < vars) status = "infinite";

        // Gauss
        let g = gaussian(A);
        g.steps.forEach((s) => addStep(gaussOutput, s.title, s.mat));

        let gDiv = document.createElement("div");
        gDiv.className = "solution-block";
        if (status === "no") {
          gDiv.innerHTML = "Solution: No Solution";
        } else if (status === "infinite") {
          gDiv.innerHTML = "Solution: Infinite Solutions";
        } else {
          let sol = backSubstitution(g.M);
          gDiv.innerHTML =
            "Solution:<br>" +
            sol.map((v, i) => `x${i + 1}=${fmt(v)}`).join("<br>");
        }
        gaussOutput.appendChild(gDiv);

        // Gauss-Jordan
        let j = gaussJordan(A);
        j.steps.forEach((s) => addStep(jordanOutput, s.title, s.mat));

        let jDiv = document.createElement("div");
        jDiv.className = "solution-block";
        if (status === "no") {
          jDiv.innerHTML = "Solution: No Solution";
        } else if (status === "infinite") {
          jDiv.innerHTML = "Solution: Infinite Solutions";
        } else {
          let jSol = readSolutionFromRREF(j.M);
          jDiv.innerHTML =
            "Solution:<br>" +
            jSol.map((v, i) => `x${i + 1}=${fmt(v)}`).join("<br>");
        }
        jordanOutput.appendChild(jDiv);

        // Inverse
        if (eq === vars) {
          let res = inverseMatrixSteps(Acoef);
          if (!res.inv) {
            inverseOutput.textContent = "Matrix has no inverse.";
          } else {
            res.steps.forEach((s) => addStep(inverseSteps, s.title, s.mat));
            inverseOutput.textContent = matrixToString(res.inv);
          }
        } else {
          inverseOutput.textContent = "No inverse (matrix not square)";
        }
      }
    </script>
  </body>
</html>
